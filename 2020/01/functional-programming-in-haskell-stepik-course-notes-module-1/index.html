<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta name="google-site-verification" content="lYE6Wy4AMVpA-paUiNWFLIZFk8vqATN4AedYdumNuVo">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Gloria Hallelujah:300,300italic,400,400italic,700,700italic|JetBrains Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hmemcpy.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="There’s a fantastic free online course (MOOC) for the Russian-speaking developer community on Stepik for learning Haskell - a two-part course titled Functional Programming in Haskell by Denis Moskvin,">
<meta property="og:type" content="article">
<meta property="og:title" content="Functional Programming in Haskell (Stepik course notes) - module 1">
<meta property="og:url" content="http://hmemcpy.com/2020/01/functional-programming-in-haskell-stepik-course-notes-module-1/index.html">
<meta property="og:site_name" content="In Absentia">
<meta property="og:description" content="There’s a fantastic free online course (MOOC) for the Russian-speaking developer community on Stepik for learning Haskell - a two-part course titled Functional Programming in Haskell by Denis Moskvin,">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-18T00:01:20.000Z">
<meta property="article:modified_time" content="2020-01-18T00:01:20.000Z">
<meta property="article:author" content="Igal Tabachnik">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hmemcpy.com/2020/01/functional-programming-in-haskell-stepik-course-notes-module-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Functional Programming in Haskell (Stepik course notes) - module 1 | In Absentia</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-70273-3"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-70273-3');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">In Absentia</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">by Igal Tabachnik</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">90</span></a>

  </li>
        <li class="menu-item menu-item-talks-i-liked">

    <a href="/talks-i-liked/" rel="section"><i class="fab fa-youtube fa-fw"></i>Talks I liked</a>

  </li>
        <li class="menu-item menu-item-cv-/-résumé">

    <a href="/cv.pdf" rel="section"><i class="fas fa-address-card fa-fw"></i>CV / Résumé</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hmemcpy.com/2020/01/functional-programming-in-haskell-stepik-course-notes-module-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/601206?v=3&s=460">
      <meta itemprop="name" content="Igal Tabachnik">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="In Absentia">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Functional Programming in Haskell (Stepik course notes) - module 1<a href="https://github.com/hmemcpy/hmemcpy.com/edit/master/source/_posts/2020-01-18-functional-programming-in-haskell-stepik-course-notes-module-1.md" class="post-edit-link" title="Edit this post" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: January 18th, 2020 02:01:20" itemprop="dateCreated datePublished" datetime="2020-01-18T02:01:20+02:00">January 18th, 2020</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2020/01/functional-programming-in-haskell-stepik-course-notes-module-1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/01/functional-programming-in-haskell-stepik-course-notes-module-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>There’s a fantastic free online course (MOOC) for the Russian-speaking developer community on <a target="_blank" rel="noopener" href="https://stepik.org/">Stepik</a> for learning Haskell - a two-part course titled <a target="_blank" rel="noopener" href="https://stepik.org/course/75">Functional Programming in Haskell</a> by Denis Moskvin, (then) associate professor at the St. Petersburg Academic University. I recently re-watched the course (having completed it previously) and decided to take notes and summarize the course content in English for your enjoyment.</p>
<p>I would like to thank Denis Moskvin for providing this amazing resource for free, and urge you, if you speak Russian and want to learn Haskell, to work through the course material and exercises!</p>
<p>Below is the summary of the first module, <strong>Introduction</strong>, out of 5.</p>
<span id="more"></span>

<ol>
<li><strong>Introduction</strong> (this page)</li>
<li><a href="/2020/01/functional-programming-in-haskell-stepik-course-notes-module-2/">Programming fundamentals</a></li>
<li>Lists</li>
<li>Data types</li>
<li>Monads</li>
</ol>
<hr>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><em>Note:</em> The original Stepik course was recorded using GHC version 7.6.3. At the time of writing this series, the latest available GHC version is 8.8.2, which may include some differences. Mainly, since version 8 of the GHC, using the keyword <code>let</code> inside GHCi is no longer required when defining functions.</p>
<h3 id="Installing-and-configuring-GHC"><a href="#Installing-and-configuring-GHC" class="headerlink" title="Installing and configuring GHC"></a>Installing and configuring GHC</h3><p>Download and install the <a target="_blank" rel="noopener" href="https://www.haskell.org/platform/">Haskell Platform</a> for your operating system.</p>
<p>The Haskell Platform contains the Glasgow Haskell Compiler (GHC), the interpreter environment (GHCi, also known as “REPL”), as well as other tools.</p>
<p>Haskell source code is written in text files having the <code>.hs</code> extension. Most text editors support the Haskell syntax in the form of syntax highlighting and code completion. Haskell uses significant indentation for scoping. Use spaces to indent your code to prevent compilation errors.</p>
<h4 id="Using-the-interpreter-GHCi"><a href="#Using-the-interpreter-GHCi" class="headerlink" title="Using the interpreter (GHCi)"></a>Using the interpreter (GHCi)</h4><p>To start the interpreter, type <code>ghci</code> in your command shell:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> $ ghci</span><br><span class="line">GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help</span><br><span class="line">Prelude&gt; _</span><br></pre></td></tr></table></figure>
<p>The standard module <code>Prelude</code> gets loaded automatically, it contains many standard types and useful functions.</p>
<p>We can start typing expressions into the interpreter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prelude&gt; 33 + 3 * 3</span><br><span class="line">42</span><br></pre></td></tr></table></figure>

<p>The interpreter will compute the expression and will display the result in the next line.</p>
<p>We can type other kinds of expressions, such as the function <code>pi</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prelude&gt; pi</span><br><span class="line">3.141592653589793</span><br><span class="line">Prelude&gt; &quot;ABC&quot; ++ &quot;DE&quot;</span><br><span class="line">&quot;ABCDE&quot;</span><br></pre></td></tr></table></figure>

<p>The default prompt can be changed using the command <code>:set prompt</code>, followed by the new prompt name:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prelude&gt; :set prompt &quot;GHCi&gt; &quot;</span><br><span class="line">GHCi&gt; _</span><br></pre></td></tr></table></figure>

<p>Note that changing the default prompt hides the name of the currently loaded module, and as such, not recommended.</p>
<h4 id="Working-with-modules"><a href="#Working-with-modules" class="headerlink" title="Working with modules"></a>Working with modules</h4><p>Create a new text file with the following definition:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Test <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="title">sayHello</span> = putStrLn <span class="string">&quot;Hello from module Test!&quot;</span></span><br></pre></td></tr></table></figure>

<p>Save the file with the name <code>test.hs</code> (in the same directory where GHCi was started), then load the file using the <code>:load</code> command:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prelude&gt; :load Test</span><br><span class="line">[1 of 1] Compiling Test             ( Test.hs, interpreted )</span><br><span class="line">Ok, one module loaded.</span><br><span class="line">*Test&gt; sayHello</span><br><span class="line">Hello from module Test!</span><br><span class="line">*Test&gt; _</span><br></pre></td></tr></table></figure>

<p>Another handy command is <code>:reload</code>, allowing you to reload the module after changing it in the text editor. Changing <strong>Hello from module Test!</strong> to <strong>Hello World from module Test!</strong>, saving the file, and typing <code>:reload</code> in GHCi:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*Test&gt; :reload</span><br><span class="line">[1 of 1] Compiling Test             ( Test.hs, interpreted )</span><br><span class="line">Ok, one module loaded.</span><br><span class="line">*Test&gt; sayHello</span><br><span class="line">Hello World from module Test!</span><br><span class="line">*Test&gt; _</span><br></pre></td></tr></table></figure>

<p>Most commands can be shortened to the first letter (unless ambiguous) - instead of <code>:load</code> and <code>:reload</code> we can type <code>:l</code> and <code>:r</code>, respectively.</p>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>In imperative languages, programs are sequences of instructions that are executed, and their result is stored in memory locations of the runtime, called variables. Subsequent instructions can refer to previous results stored in those variables. In most imperative languages, variables can be modified during the execution of the program.</p>
<p>In functional languages, programs are expressions, and executing the program means <em>reducing</em> those expressions until it’s no longer possible to reduce it further. Reduced expressions are the result of the program execution.</p>
<p>Here’s an example of a mathematical expression, and its reduction steps:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(5 + 4 * 3) ^ 2</span><br><span class="line"> ~&gt; (5 + 12) ^ 2</span><br><span class="line"> ~&gt; 17 ^ 2</span><br><span class="line"> ~&gt; 289</span><br></pre></td></tr></table></figure>

<p>The first line contains the body of the expression, and each subsequent line is the reduction step. The resulting expression which cannot be further reduced is the final result 289. In future modules we’ll use the squiggly-arrow ~&gt; to describe reduction steps of an expression.</p>
<h4 id="Function-application"><a href="#Function-application" class="headerlink" title="Function application"></a>Function application</h4><p>Let’s talk about applying functions and the role of parentheses.</p>
<p>We’ll start by writing two identifiers, <code>foo</code> and <code>bar</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; foo bar</span><br></pre></td></tr></table></figure>

<p>Those identifiers are not defined anywhere, but syntactically they mean “apply the function <code>foo</code> to the argument <code>bar</code>“. In other languages, we usually place the argument in parentheses, e.g. <code>foo(bar)</code> in the C language. In Haskell, calling a function does not require placing its arguments in parentheses, but rather they are used to group sequences of functions together.</p>
<p>In the following expression:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; acos (cos pi)</span><br><span class="line">3.141592653589793</span><br></pre></td></tr></table></figure>
<p>we first calculate the result of applying <code>cos</code> to <code>pi</code> followed by applying <code>acos</code> to the result.</p>
<p>If a function takes multiple parameters, they are applied in order, separated by a space:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; max 5 42</span><br><span class="line">42</span><br></pre></td></tr></table></figure>

<p>Here we’re applying the function <code>max</code>, which takes two arguments, to the values <code>5</code> and <code>42</code>. This function returns the larger of the two arguments, resulting in 42.</p>
<p>Another, equivalent form of writing the previous expression is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (max 5) 52</span><br><span class="line">42</span><br></pre></td></tr></table></figure>

<p>This equivalence is called left-associativity. It is said that function application associates to the left, causing the two-argument function <code>max</code> to be applied first to the value 5, resulting in a one-argument function, which is further applied to 42.</p>
<p>Applying functions to just some of its arguments is called <em>partial application</em>. In this form, <code>(max 5)</code> is a partially-applied function that expects an additional argument to produce a result. Suppose the expression:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 3 + sin 42</span><br><span class="line">2.0834784520843663</span><br></pre></td></tr></table></figure>

<p>In this expression, <code>sin</code> is a function that expects one argument. We can replace it with our partially applied <code>(max 5)</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 3 + (max 5) 42</span><br><span class="line">45</span><br></pre></td></tr></table></figure>

<p>Here, the result of <code>(max 5)</code> applied to 42 will be 42, which will be added with 3 to result in the value 45.</p>
<p>Partial application is a very powerful tool. In Haskell we can formalize it as follows: a function of <em>n</em> arguments can be viewed as a function of <em>one</em> argument, returning a function of <em>n - 1</em> arguments.</p>
<h4 id="Declaring-functions"><a href="#Declaring-functions" class="headerlink" title="Declaring functions"></a>Declaring functions</h4><p>To define a function we need to give it a name, followed by its parameters, followed by the <code>=</code> sign, after which we specify the function body. Let’s define a function that sums the squares of its two arguments:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sumSquares x y = x ^ 2 + y ^ 2</span><br><span class="line"></span><br><span class="line">     ^     ^ ^   ^^^^^^^^^^^^^</span><br><span class="line">     |     | |   |</span><br><span class="line">     |     | |   +-- function body</span><br><span class="line">     |     | +------ second argument</span><br><span class="line">     |     +-------- first argument </span><br><span class="line">     +-------------- function name</span><br></pre></td></tr></table></figure>

<p>After defining this function, we can now call it:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sumSquares 1 2</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>Haskell requires all functions and formal parameter names to start with a lowercase letter. Names starting with an uppercase letter are used to define data types. Haskell function names can contain numbers (as long as they’re not the first letter), as well as underscores, and a single quote (<code>&#39;</code>) is often used. The name <code>rock&#39;n&#39;roll</code> is a valid Haskell identifier.</p>
<h4 id="Pure-functions"><a href="#Pure-functions" class="headerlink" title="Pure functions"></a>Pure functions</h4><p>What sets Haskell apart from many other programming languages if the fact that Haskell functions are <em>pure</em> - the meaning of a Haskell function is completely specified by its input arguments. No other inputs can influence the result of a pure function. It is said that a pure function has no <em>side-effects</em>. As a result, a function that does not take any arguments is a <em>constant</em> - it will always yield the same result.</p>
<p>The following function:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; fortyTwo = 39 + 3</span><br><span class="line">&gt; fortyTwo</span><br><span class="line">42</span><br></pre></td></tr></table></figure>

<p>Will always produce the value 42, regardless of when and where it is executed. It is not possible in Haskell to define a function of no arguments that returns different results on different calls. To create functions that produce random values we will need to use a special <em>container</em> called <code>IO</code>, which will be introduced in later modules.</p>
<h4 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h4><p>Many programming languages contain a conditional operator <code>if</code>, that is used to branch program execution, depending on some condition. In imperative languages, the <code>if</code> condition may or may not be followed by an <code>else</code> branch. Haskell also contains a conditional <code>if</code> operator that is syntactically similar to the imperative one.</p>
<p>Let’s define a function <code>f</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; f x = if x &gt; 0 then 1 else (-1)</span><br><span class="line">&gt; f 5</span><br><span class="line">1</span><br><span class="line">&gt; f (-5)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>This function takes a numeric value <code>x</code> and returns 1 if <code>x</code> is greater than 0, otherwise -1. When used as arguments, negative numbers in Haskell must be enclosed in parentheses, e.g. (-5) means the argument -5.</p>
<p>Functional languages like Haskell require both branches <code>then</code> and <code>else</code> to be defined. Both branches must contain expressions of the same type, otherwise, it will be a compilation error. The other major difference between functional and imperative languages is the fact that conditionals are expressions too. It means that conditional expressions could be used in building other, larger expressions:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; g x = (if x &gt; 0 then 1 else (-1)) + 3</span><br><span class="line">&gt; g 5</span><br><span class="line">4</span><br><span class="line">&gt; g (-7)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>Here in function <code>g</code>, we add 3 to the result of the conditional expression.</p>
<h4 id="Partial-application"><a href="#Partial-application" class="headerlink" title="Partial application"></a>Partial application</h4><p>Let’s suppose we want to define a function <code>max5</code> which takes a single argument. It will return this argument if it’s greater than 5, otherwise 5. We can use the existing <code>max</code> function:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; max5 x = max 5 x</span><br><span class="line">&gt; max5 4</span><br><span class="line">5</span><br><span class="line">&gt; max5 42</span><br><span class="line">42</span><br></pre></td></tr></table></figure>

<p>In Haskell, we can write a shorter version of this function, by dropping the argument <code>x</code> on both sides of the equals sign. Let’s call it <code>max5&#39;</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; max5&#x27; = max 5</span><br><span class="line">&gt; max5&#x27; 4</span><br><span class="line">5</span><br><span class="line">&gt; max5&#x27; 42</span><br><span class="line">42</span><br></pre></td></tr></table></figure>

<p>It behaves exactly as <code>max5</code>, but here the partial application is more obvious: the function <code>max</code> is partially applied to the value 5, resulting in a function of a single argument. This style of defining a function without specifying all of the parameters is quite pervasive in Haskell, and it’s called the <em>point-free</em> style.</p>
<p>Let’s look at another example, a function <code>discount</code> that calculates a discount given some percentage if the sum is greater than some limit:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; discount limit pct sum = if sum &gt;= limit then sum * (100 - pct) / 100 else sum</span><br></pre></td></tr></table></figure>

<p>The order of parameters in this definition is a little weird. In Haskell, oftentimes functions are designed to prioritize making partial application convenient. In the case of our <code>discount</code> function, we suppose that the arguments <code>limit</code> and <code>pct</code> would rarely change, while the <code>sum</code> argument may be different each time. We can introduce another function, <code>standardDiscount</code>, which offers a standard discount of 5% for sums over 1000:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; discount limit pct sum = if sum &gt;= limit then sum * (100 - pct) / 100 else sum</span><br><span class="line">&gt; standardDiscount = discount 1000 5</span><br></pre></td></tr></table></figure>

<p>This is a partially-applied function, the parameter <code>sum</code> is not specified on either side (although it could have been). We can now call the <code>standardDiscount</code> function with just one parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; standardDiscount 2000</span><br><span class="line">1900.0</span><br><span class="line">&gt; standardDiscount 900</span><br><span class="line">900</span><br></pre></td></tr></table></figure>

<h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><p>Operators exist in Haskell just like functions but are called in a slightly different style. Suppose the expression <code>max 6 7</code>. It is written in a so-called <em>prefix</em> style, where the function name <code>max</code> is prefixing the arguments. In contrast, operators are usually written in an <em>infix</em> style, e.g. <code>6 + 7</code> - the operator <code>+</code> is infixed between its two arguments.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; max 6 7</span><br><span class="line">7</span><br><span class="line">&gt; 6 + 7</span><br><span class="line">13</span><br></pre></td></tr></table></figure>

<p>However, in Haskell, this distinction can be removed by writing functions in an infix (“operator”) style, and operators in a prefix (“functional”) style. Functions surrounded by backticks (<code>`</code>) and written between the arguments can be used as operators:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 6 `max` 7</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p>To use operators in a functional style, they have to be placed in parentheses:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (+) 6 7</span><br><span class="line">13</span><br></pre></td></tr></table></figure>

<p>Nearly all operators in Haskell are binary, meaning they accept two arguments. In the example above we turned the binary operator <code>+</code> to a binary function <code>(+)</code> applied to two arguments. The only exception is the unary <code>-</code> operator which negates numeric values. To avoid collisions between binary and unary <code>-</code> we enclose negative numbers in argument positions in parentheses:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; - 7</span><br><span class="line">-7</span><br><span class="line">&gt; (-) 5 3</span><br><span class="line">2</span><br><span class="line">&gt; max (-5) 5</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h4 id="Operator-precedence-and-associativity"><a href="#Operator-precedence-and-associativity" class="headerlink" title="Operator precedence and associativity"></a>Operator precedence and associativity</h4><p>Suppose the following expression:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 3 + 5 * 8</span><br><span class="line">43</span><br></pre></td></tr></table></figure>

<p>From mathematics, we know that multiplication precedes addition. Haskell also knows about this, because the addition and multiplication operators have a certain <em>precedence</em>. The multiplication operator has a higher precedence than addition, and Haskell uses this information when evaluating the expression.</p>
<p>A precedence level is a number from 0 to 9, bigger means higher. Function application in Haskell is considered having a precedence level 10 - highest possible, which is why the expression <code>sin 5 + 4</code> is first evaluated by calculating <code>sin 5</code> and then adding 4 to the result. All operators have lower precedence than function application.</p>
<p>Associativity is taken into account when operators lack associativity rules. The expression <code>3 - 9 - 5</code> could be viewed in two ways:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (3 - 9) - 5</span><br><span class="line">-11</span><br></pre></td></tr></table></figure>

<p>also known as <em>left-associative</em>, or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 3 - (9 - 5)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>known as <em>right-associative</em>.</p>
<p>From mathematics, subtraction is a left-associative operation, and Haskell will give us the correct result without using any parentheses:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 3 - 9 - 5</span><br><span class="line">-11</span><br></pre></td></tr></table></figure>

<p>To define operator associativity, Haskell uses the keywords <code>infixl</code> and <code>infixr</code> for left and right associativity, respectively, or <code>infix</code> for operators without associativity rules. The keyword is followed by the precedence level and the operator name.</p>
<p>Here are some operators defined in the standard library:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infixr</span> <span class="number">8</span> ^, `logBase`</span><br><span class="line"><span class="keyword">infixl</span> <span class="number">7</span> *, `div`, `mod`</span><br><span class="line"><span class="keyword">infixl</span> <span class="number">6</span> +, -</span><br><span class="line"><span class="keyword">infix</span> <span class="number">4</span> ==, /=, &gt;, &gt;=, &lt;, &lt;=</span><br></pre></td></tr></table></figure>

<p>Using functions in operator (infix) style, such as <code>logBase</code> will have defined associativity and precedence levels. In this case, <code>logBase</code> in operator mode is right-associative, having precedence level 8.</p>
<p>Any operator lacking a fixity declaration is assumed to be <code>infixl 9</code>.</p>
<h4 id="Operator-definition"><a href="#Operator-definition" class="headerlink" title="Operator definition"></a>Operator definition</h4><p>Haskell does not have built-in operators. All operators used until now (<code>+</code>, <code>*</code>, etc.) are defined in the standard library. Haskell allows users to define custom operators, using a combination of any of the following symbols:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! # $ % &amp; * + . / &lt; = &gt; ? @ \ ^ | - ~</span><br></pre></td></tr></table></figure>

<p>The symbol <code>:</code> can also be used, but it has special meaning in various Haskell constructs, so it’s best to avoid using it as an operator.</p>
<p>Let’s create a custom operator <code>*+*</code> for the sum of squares function. To define it, we first declare its associativity and precedence, say left-associative and 6, followed by the definition:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infixl</span> <span class="number">6</span> *+*</span><br><span class="line"></span><br><span class="line"><span class="title">a</span> *+* b = a ^ <span class="number">2</span> + b ^ <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Let’s load it in the REPL, and indeed it works:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 3 *+* 4</span><br><span class="line">&gt; 25</span><br></pre></td></tr></table></figure>

<p>It can also be used in the functional style by enclosing it in parentheses:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (*+*) 3 4</span><br><span class="line">25</span><br></pre></td></tr></table></figure>

<p>We could also define the operator in the prefix style:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infixl</span> <span class="number">6</span> *+*</span><br><span class="line"></span><br><span class="line">(*+*) a b = a ^ <span class="number">2</span> + b ^ <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="Operator-section"><a href="#Operator-section" class="headerlink" title="Operator section"></a>Operator section</h4><p>In Haskell, there’s a special syntax for partially applying infix operators, called <em>section</em>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (2 /)</span><br></pre></td></tr></table></figure>

<p>Here we bind the first (left) argument of the division operator with the value 2. Applying it to another number will give us:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (2 /) 4</span><br><span class="line">0.5</span><br></pre></td></tr></table></figure>

<p>We can also bind the right argument, giving us a division by 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (/ 2) 4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>This is called <em>left section</em> and <em>right section</em>, respectively. To use the section, the operator and the value must be enclosed in parentheses. The only exception to this is the <code>-</code> operator, which will negate the number instead:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (- 2)</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>

<h4 id="The-operator"><a href="#The-operator" class="headerlink" title="The $ operator"></a>The <code>$</code> operator</h4><p>Function application in Haskell is written with a space between the function name and its arguments, e.g. <code>f x</code>. We can instead think a custom operator <code>$</code> for function application:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">f</span> $ x = f x</span><br></pre></td></tr></table></figure>

<p>Such an operator already exists in the Haskell standard library, and it is used in the following manner:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sin $ 0</span><br><span class="line">0.0</span><br></pre></td></tr></table></figure>

<p>This is equivalent to calling <code>sin 0</code>, so why do we need another operator? It turns out the <code>$</code> operator has the lowest possible precedence level (0), and it allows removing excess parentheses when using expressions with multiple functions. Suppose an expression:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sin (pi / 2)</span><br><span class="line">1.0</span><br></pre></td></tr></table></figure>

<p>Without grouping <code>pi / 2</code> in parentheses, Haskell would first evaluate <code>sin pi</code> (due to the highest precedence of function application) and then apply <code>/ 2</code> to the result. Using the <code>$</code> operator we can <em>lower</em> the precedence level of function application, allowing first to calculate <code>pi / 2</code> and only then apply <code>sin</code> to the result:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sin $ pi / 2</span><br><span class="line">1.0</span><br></pre></td></tr></table></figure>

<p>Moreover, the <code>$</code> operator is right-associative, which allows in most cases to remove parentheses from expressions on the right side. The following expressions are equivalent:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f (g x (h y)) == f $ g x (h y) == f $ g x $ h y</span><br></pre></td></tr></table></figure>

<p>The <code>$</code> operator is used pervasively in Haskell code bases due to its usefulness.</p>
<h3 id="Base-types"><a href="#Base-types" class="headerlink" title="Base types"></a>Base types</h3><p>Haskell is a strong, statically-typed programming language. The term <em>strong</em> means that Haskell lacks implicit conversion between types, and <em>static</em> means that type checking is done during compilation, rather than the run time.</p>
<p>Haskell has strong <em>type inference</em>, allowing it to deduce (infer) the correct type of almost all expressions unless there’s an error in the expression, in which case Haskell will report a type-checking error.</p>
<p>To learn the type of any expression in Haskell there exists the command <code>:type</code> (<code>:t</code> for short). Typing it, followed by an expression:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :type &#x27;c&#x27;</span><br><span class="line">&#x27;c&#x27; :: Char</span><br></pre></td></tr></table></figure>

<p>gives us the information that <code>&#39;c&#39;</code> is of type <code>Char</code>. The <code>::</code>, which can be read as “has type” or “is of type”, is a typing operator, which binds the expressions (“terms”) on the left with their type on the right. In most cases, type names in Haskell start with a capital letter.</p>
<p>The <code>Char</code> type includes all symbols of the alphabet, including Unicode symbols and control symbols, such as new line:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :type &#x27;\n&#x27;</span><br><span class="line">&#x27;\n&#x27; :: Char</span><br></pre></td></tr></table></figure>

<p>However, if we enter in single quotes a non-char value, GHCi will report an error:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :type &#x27;zz&#x27;</span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:1:1: error:</span><br><span class="line">    • Syntax error on &#x27;zz&#x27;</span><br><span class="line">      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes</span><br><span class="line">    • In the Template Haskell quotation &#x27;zz&#x27;</span><br></pre></td></tr></table></figure>

<p>Another common type is <code>Bool</code>, which is inhabited by two values, <code>True</code> and <code>False</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :t True</span><br><span class="line">True :: Bool</span><br><span class="line">&gt; :t False</span><br><span class="line">False :: Bool</span><br></pre></td></tr></table></figure>

<h4 id="Numeric-types"><a href="#Numeric-types" class="headerlink" title="Numeric types"></a>Numeric types</h4><p>Haskell has a variety of numeric types, like <code>Int</code> (for 32&#x2F;64 bit integers), <code>Integer</code> (arbitrary precision type, up to the limit of machine memory), as well as floating-point types like <code>Float</code> and <code>Double</code>.</p>
<p>All of these numeric types are members of the <em>type class</em> <code>Num</code> (we’ll learn more about type classes in future modules). The type class mechanism in Haskell is used to provide a common “interface” for all numeric values, for example, the ability to add numbers using the same operator <code>+</code>.</p>
<p>Let’s look at the type of some number literals in GHCi:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :t 3</span><br><span class="line">3 :: Num a =&gt; a</span><br></pre></td></tr></table></figure>

<p>We can see that Haskell numbers are strangely defined: the type of the literal 3 is an arbitrary type <code>a</code>, which is prefixed with a certain <em>context</em> called <code>Num a</code>. We say that <code>a</code> is <em>constrained</em> by the <code>Num</code> type class.</p>
<p>However, we can also specify a concrete type when using literals. In this definition:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; x = 3 :: Int</span><br><span class="line">&gt; x</span><br><span class="line">3</span><br><span class="line">&gt; :t x</span><br><span class="line">x :: Int</span><br></pre></td></tr></table></figure>

<p>We bind the identifier <code>x</code> with the <code>Int</code> value 3. We can also specify another type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; y = 3 :: Double</span><br><span class="line">&gt; y</span><br><span class="line">3.0</span><br><span class="line">&gt; :t y</span><br><span class="line">y :: Double</span><br></pre></td></tr></table></figure>

<p>This works because <code>Double</code> is also a member of the type class <code>Num</code>, allowing us to satisfy the constraint of the literal 3 in the context of <code>Double</code>.</p>
<p>Creating another value <code>z</code>, to which we add <code>Double</code> and <code>Int</code> values:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; z = y + 17</span><br><span class="line">&gt; :t z</span><br><span class="line">z :: Double</span><br></pre></td></tr></table></figure>

<p>This results in <code>Double</code> since the literal 17 is <em>polymorphic</em> in its return type, and since the <code>+</code> operator must return the same type as its arguments, we use the existing <code>Double</code> constraint of <code>y</code>, and the resulting type is <code>Double</code>.</p>
<p>As we’ve seen, whole numbers belong to the type class <code>Num</code>, while floating-point numbers belong to another type class, <code>Fractional</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :t 3.5</span><br><span class="line">3.5 :: Fractional a =&gt; a</span><br></pre></td></tr></table></figure>

<p>The <code>Float</code> and <code>Double</code> types belong to the <code>Fractional</code> type class, while <code>Int</code> and <code>Integer</code> do not.</p>
<p>The <code>Integer</code> type can inhabit any arbitrary-length integer value, limited only by the computer’s memory. The <code>Int</code> type can be either 32- or 64-bit, depending on the architecture:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 123456789012345678901234567890 :: Integer</span><br><span class="line">123456789012345678901234567890</span><br><span class="line">&gt; 123456789012345678901234567890 :: Int</span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:20:1: warning: [-Woverflowed-literals]</span><br><span class="line">    Literal 123456789012345678901234567890 is out of the Int range -9223372036854775808..9223372036854775807</span><br></pre></td></tr></table></figure>

<h4 id="Function-types"><a href="#Function-types" class="headerlink" title="Function types"></a>Function types</h4><p>Function type signatures in Haskell are written with an infix arrow <code>-&gt;</code>, with the argument type on the left of the arrow, and the result type is on the right.</p>
<p>Haskell has a boolean <code>not</code> function, taking a boolean value and negates it. Let’s see what it looks like in the REPL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; not False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>Since <code>not</code> is a function that takes a <code>Bool</code> type and returns a <code>Bool</code> type, its type signature is written as <code>Bool -&gt; Bool</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :t not</span><br><span class="line">not :: Bool -&gt; Bool</span><br></pre></td></tr></table></figure>

<p>In the case of two (or more) arguments, the type signature looks like this (using the binary <code>&amp;&amp;</code> (logical AND) function):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (&amp;&amp;) False True</span><br><span class="line">False</span><br><span class="line">&gt; :t (&amp;&amp;)</span><br><span class="line">(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool</span><br></pre></td></tr></table></figure>

<p>Recall that every function of <em>n</em> arguments in Haskell can be viewed as a function of 1 argument, returning another function of <em>n - 1</em> arguments. In this case, the function <code>&amp;&amp;</code> can be viewed as:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ((&amp;&amp;) False) True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>where <code>((&amp;&amp;) False)</code> is a partially applied function that expects one more <code>Bool</code> argument, making its return type a <code>Bool -&gt; Bool</code> function. The complete expression can thus be written as <code>Bool -&gt; (Bool -&gt; Bool)</code>. The <code>-&gt;</code> operator is right-associative, so the parentheses can be removed, resulting in a type <code>Bool -&gt; Bool -&gt; Bool</code>.</p>
<p>We can view the rightmost parameter in the type signature as the return type, making all preceding parameters the argument types. Thus, <code>Bool -&gt; Bool -&gt; Bool</code> is read “a function of two <code>Bool</code> arguments, returning a <code>Bool</code>“.</p>
<h4 id="Importing-functions"><a href="#Importing-functions" class="headerlink" title="Importing functions"></a>Importing functions</h4><p>The standard Prelude contains many often-used functions, but not all. To gain access to other functions, defined in other modules, those modules first have to be <em>imported</em>.</p>
<p>Importing modules is done by using the keyword <code>import</code>, followed by the module name:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Demo <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Char</span><br></pre></td></tr></table></figure>

<p>This gives us access to all functions exported by the module <code>Data.Char</code>, such as <code>isDigit</code>. Modules can also be imported directly in GHCi:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prelude&gt; import Data.Char</span><br><span class="line">Prelude Data.Char&gt; isDigit &#x27;7&#x27;</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>To find the module and name of specific functions, we can use <a target="_blank" rel="noopener" href="https://hoogle.haskell.org/">Hoogle</a> to look them up by name or type signature.</p>
<h4 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h4><p>Tuples are fixed-length couplings of arbitrary values, written in parentheses and separated by commas. The following syntax creates a tuple:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; (2,True) -- two-element tuple (also known as a pair)</span><br><span class="line">(2,True)</span><br><span class="line">&gt; (2,True,&#x27;c&#x27;) -- three-element tuple</span><br><span class="line">(2,True,&#x27;c&#x27;)</span><br></pre></td></tr></table></figure>

<p>For pairs, there exist several helpful functions:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; fst (2,True) -- returns the first element of a pair</span><br><span class="line">2</span><br><span class="line">&gt; snd (2,True) -- returns the second element</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>The type of a tuple consists of all types contained within the tuple:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :t (&#x27;x&#x27;,True)</span><br><span class="line">(&#x27;x&#x27;,True) :: (Char, Bool)</span><br></pre></td></tr></table></figure>

<p>Haskell does not have a single-value tuple, writing e.g. <code>(3)</code> is the same as writing the literal <code>3</code>. However, there’s an “empty tuple” <code>()</code>, whose type is:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :t ()</span><br><span class="line">() :: ()</span><br></pre></td></tr></table></figure>

<p>Here the value <code>()</code> and the type <code>()</code> are the same, but it is allowed since values and types exist in different namespaces.</p>
<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><p>Lists, like tuples, are containers of values. Unlike tuples, however, lists can only contain values of the same type (lists are so-called “homogenous”, meaning all values must belong to the same type, versus “heterogeneous” tuples). Another difference is that the length of the list is not fixed and not known in compilation time. A list may also be empty.</p>
<p>Lists in Haskell are written in square brackets <code>[]</code>. Here’s the syntax to create a list:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; [1,2,3]</span><br><span class="line">[1,2,3]</span><br><span class="line">&gt; [False,True]</span><br><span class="line">[False,True]</span><br></pre></td></tr></table></figure>

<p>Since lists are homogenous, their type does not depend on their length. A type of a list of booleans is:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :t [False,True]</span><br><span class="line">[False,True] :: [Bool]</span><br></pre></td></tr></table></figure>

<p>Here, the square brackets on the left specify the value of the list, and on the right is the type of the list, also placed in squared brackets. Here, <code>[Bool]</code> a list of <code>Bool</code> values.</p>
<p>For lists of type <code>[Char]</code> there exists a special syntax. A list of characters:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; [&#x27;H&#x27;,&#x27;i&#x27;]</span><br><span class="line">&quot;Hi&quot;</span><br></pre></td></tr></table></figure>

<p>will be displayed as a String. The type of a list of characters is the same as the type of <code>String</code>. Haskell defines a <code>String</code> as a type alias of <code>[Char]</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; :t [&#x27;H&#x27;,&#x27;i&#x27;]</span><br><span class="line">[&#x27;H&#x27;,&#x27;i&#x27;] :: [Char]</span><br><span class="line">&gt; :t &quot;Hi&quot;</span><br><span class="line">&quot;Hi&quot; :: [Char]</span><br></pre></td></tr></table></figure>

<p>Lists are one of the most fundamental data types in Haskell and functional programming in general. We’ll discuss operations on lists in future modules, but for now, we’ll mention two of the most common operations: adding an element to the head of the list and concatenating two lists together.</p>
<p>To add (prepend) an element to the head of the list we use the <code>:</code> operator:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; str = &#x27;H&#x27; : &quot;ello&quot;</span><br><span class="line">&gt; str</span><br><span class="line">&quot;Hello&quot;</span><br></pre></td></tr></table></figure>

<p>To append (concatenate) two lists together we use the <code>++</code> operator:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; str ++ &quot; world&quot;</span><br><span class="line">&quot;Hello world&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3><p>In imperative languages, the main tool for performing repetitive operations is a loop. In functional languages, loops are not meaningful, since those languages often lack the concept of a mutable variable, so it cannot be used to distinguish one loop iteration from the next.</p>
<p>In functional languages, repetition is done using recursion. The function is considered recursive if it contains in its right-hand side a call to the same function. Let’s look at such a definition:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial</span> n = <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> n * factorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>Recursive functions must obey two rules in order not to get stuck in an infinite cycle:</p>
<ol>
<li>calling a function recursively must be done on a value that differs from the input value of its formal parameter</li>
<li>there must exist a terminating condition to break the recursion</li>
</ol>
<p>In our case we obey both rules: the recursive call to <code>factorial</code> is done on a value that’s less than the input value <code>n</code>, and we have a conditional branch that does not result in a recursive call, allowing the function to terminate.</p>
<p>To visualize the way Haskell evaluates this expression we can use substitution to replace formal parameters with the actual values:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">factorial 2</span><br><span class="line"> ~&gt; if 2 == 0 then 1 else 2 * factorial 1</span><br><span class="line"> ~&gt; 2 * factorial 1</span><br><span class="line"> ~&gt; 2 * (if 1 == 0 then 1 else 1 * factorial 0)</span><br><span class="line"> ~&gt; 2 * factorial 0</span><br><span class="line"> ~&gt; 2 * (if 0 == 0 then 1 else 0 * factorial (-1))</span><br><span class="line"> ~&gt; 2 * 1</span><br><span class="line"> ~&gt; 2</span><br></pre></td></tr></table></figure>

<p>Each reduction step consists of replacing any formal parameter with the result of this parameter. In this case, <code>n</code> has the value 2, initially, and each recursive call reduces the value by 1. Finally, we reach the condition where <code>n</code> is 0, and the recursion terminates, returning the value 1. It is multiplied by the initial value 2, resulting in 2 as the final result of this function.</p>
<h4 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h4><p>Using conditional expressions in Haskell is not always convenient. Haskell has a much more powerful mechanism for this purpose called <em>pattern matching</em>. The main idea is that the function is defined using not just one equation, but several, each describing a possible branch.</p>
<p>Rewriting <code>factorial</code> to use the pattern matching style:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial&#x27;</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">factorial&#x27;</span> n = n * factorial&#x27; (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>The new definition <code>factorial&#39;</code> is written using two definitions. The difference between the two is how we describe function parameters. In the first definition, we bind the parameter not with a variable, but with a <em>possible</em> constant value. Here, 0 serves as a <em>pattern</em>, against which the value of <code>n</code> will be <em>matched</em>. If the match is successful, the function returns its value, otherwise, the next pattern will be tried. The second definition is called an <em>irrefutable</em> pattern - it can always be used to bind the parameter <code>n</code> with any value that is passed to it.</p>
<h4 id="Errors-and-early-termination"><a href="#Errors-and-early-termination" class="headerlink" title="Errors and early termination"></a>Errors and early termination</h4><p>If a negative value is given to our <code>factorial</code> function, it will never reach the terminating condition (it will never <em>converge</em>) and will enter an endless loop (the program <em>diverges</em>). In the general case, this is unavoidable, since there are functions that are not defined for all arguments. However, hanging in an endless loop is the worst possible thing for the function to do. It would be better for the function to terminate and report an error to the diagnostic stream. There are two functions in the standard library to help deal with such errors - <code>error</code> and <code>undefined</code>.</p>
<p>The <code>error</code> function takes a <code>String</code> of text as an argument and prints an error with this text:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; error &quot;ABC&quot;</span><br><span class="line">*** Exception: ABC</span><br></pre></td></tr></table></figure>

<p>The <code>undefined</code> function does not take any arguments, it always terminates with an error message:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; undefined</span><br><span class="line">*** Exception: Prelude.undefined</span><br></pre></td></tr></table></figure>

<p>We can now augment the <code>factorial</code> function using one of these functions:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial&#x27;&#x27;</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">factorial&#x27;&#x27;</span> n = <span class="keyword">if</span> n &lt; <span class="number">0</span> <span class="keyword">then</span> error <span class="string">&quot;arg must be &gt;= 0&quot;</span> <span class="keyword">else</span> n * factorial&#x27;&#x27; (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>Now calling this function with a negative number will terminate the program immediately with a helpful message.</p>
<p>Both <code>error</code> and <code>undefined</code> are useful when writing programs in Haskell. In Haskell’s type semantics, both non-terminating recursion and early termination with an error are indistinguishable. In this case, it is considered that the return type of such programs is a special term called <em>bottom</em> (denoted by the mathematical symbol ⊥), which signifies a computation that never completes successfully. </p>
<p>The bottom value is an element of all Haskell types, and the and <code>undefined</code> function provides a way to use this value. The <code>undefined</code> function can be substituted in place of any other expression in the program, and it is often used to mark yet unimplemented segments of code, but that the type checker accepts.</p>
<h4 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h4><p>Sometimes, pattern matching is not a suitable syntax for dealing with complex conditions. Haskell contains another mechanism called <em>guards</em>, which allows better specifying conditions for handling specific cases. Let’s rewrite <code>factorial</code> yet again, using the new syntax:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial&#x27;&#x27;&#x27;</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">factorial&#x27;&#x27;&#x27;</span> n | n &lt; <span class="number">0</span> = error <span class="string">&quot;arg must be &gt;= 0&quot;</span></span><br><span class="line">               | n &gt; <span class="number">0</span> = n * factorial<span class="string">&#x27;&#x27;</span>&#x27; (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>Here, the guard expressions allow specifying boolean conditions. If the guard condition is <code>True</code>, the right-hand expression is returned, otherwise, we continue to the next guard condition. If no guard conditions were satisfied, and there are no more conditions, the pattern matching fails with an error.</p>
<p>We can rewrite <code>factorial</code> using only guards in the following manner:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">factorial4 n | n == 0    = 1</span><br><span class="line">             | n &gt; 0     = n * factorial4 (n - 1)</span><br><span class="line">             | otherwise = error &quot;arg must be &gt;= 0&quot;</span><br></pre></td></tr></table></figure>

<p>The function <code>otherwise</code> will always resolve to <code>True</code>, and we’ll always reach it in case all other guard conditions were not satisfied.</p>
<h4 id="Recursion-with-accumulation"><a href="#Recursion-with-accumulation" class="headerlink" title="Recursion with accumulation"></a>Recursion with accumulation</h4><p>If we wrote our factorial in C, we’d declare an accumulating variable holding an initial value, and would modify this variable in a loop, returning the accumulated value:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">factorial</span> <span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">long</span> acc = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">    acc *= n--;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Haskell has no loops and no mutable variables, however, we can implement the same idea using an additional parameter:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial5</span> = n | n &gt;= <span class="number">0</span>    = helper <span class="number">1</span> n</span><br><span class="line">               | otherwise = error <span class="string">&quot;arg must be &gt;= 0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title">helper</span> acc <span class="number">0</span> = acc</span><br><span class="line"><span class="title">helper</span> acc n = helper (acc * n) (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>Our new definition is split into two parts: the definition of <code>factorial5</code>, which does argument checking, calling the helper function, and the <code>helper</code> function which has two parameters: an accumulator <code>acc</code> and the initial value <code>n</code>.</p>
<p>The <code>helper</code> function will on each recursive call decrease the value <code>n</code>, but also multiply its current value with the accumulator. Both conditions for recursion termination still hold: we’re calling <code>helper</code> recursively with a different value <code>n</code>, and we have a terminating condition in the pattern match where <code>n</code> is 0.</p>
<p>In the case of the factorial function above, using the additional accumulator does not provide any extra benefits in Haskell, however, it is very often used to increase recursion efficiency and performance.</p>
<h3 id="Local-Bindings"><a href="#Local-Bindings" class="headerlink" title="Local Bindings"></a>Local Bindings</h3><h4 id="Significant-whitespace"><a href="#Significant-whitespace" class="headerlink" title="Significant whitespace"></a>Significant whitespace</h4><p>Haskell uses indentation for scoping. Haskell defines tabs to use 8 spaces, regardless of the configuration of your editor, and the use of spaces is encouraged.</p>
<p>Let’s look at the function <code>roots</code> defined below:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">roots</span> :: <span class="type">Double</span> -&gt; <span class="type">Double</span> -&gt; <span class="type">Double</span></span><br><span class="line">          -&gt; (<span class="type">Double</span> -&gt; <span class="type">Double</span>)</span><br><span class="line"><span class="title">roots</span> a b c =</span><br><span class="line">  (</span><br><span class="line">    (-b - sqrt (b ^ <span class="number">2</span>) - <span class="number">4</span> * a * c)) / (<span class="number">2</span> * a)</span><br><span class="line">  ,</span><br><span class="line">    (-b + sqrt (b ^ <span class="number">2</span>) - <span class="number">4</span> * a * c)) / (<span class="number">2</span> * a)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>The function definition here begins at indentation 0. On the first and 3<sup>rd</sup> lines we have a declaration of the type signature and the definition itself. The type signature is spread on two lines. The signature continues on the second line, and we could have broken it down further, as long as there’s a non-zero indentation. Here is another example of a valid definition:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">roots</span> :: <span class="type">Double</span></span><br><span class="line">      -&gt; <span class="type">Double</span> </span><br><span class="line">      -&gt; <span class="type">Double</span></span><br><span class="line">      -&gt; (<span class="type">Double</span> -&gt; <span class="type">Double</span>)</span><br></pre></td></tr></table></figure>

<p>Any line starting at indentation 0 means we are starting a new global definition. Inside the function body, any indentation can be arbitrarily used so long as the indentation remains above 0.</p>
<h4 id="Removing-duplication-using-let-in"><a href="#Removing-duplication-using-let-in" class="headerlink" title="Removing duplication using let .. in"></a>Removing duplication using <code>let .. in</code></h4><p>In the <code>roots</code> function above we repeat a sub-expression, namely <code>sqrt (b ^ 2) - 4 * a * c</code>, twice. To remove this duplication, we’d like to bind this sub-expression with a name and use this named expression instead.</p>
<p>Haskell includes a construct for such local bindings called <code>let .. in</code>. Here’s another version of <code>roots</code>:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">roots&#x27;</span> a b c =</span><br><span class="line">  <span class="keyword">let</span> d = sqrt (b ^ <span class="number">2</span> - <span class="number">4</span> * a * c) <span class="keyword">in</span></span><br><span class="line">  ((-b - d) / (<span class="number">2</span> * a), (-b + d) / (<span class="number">2</span> * a))</span><br></pre></td></tr></table></figure>

<p>The <code>let .. in</code> construct has two parts: the first part after the keyword <code>let</code> defines the local binding - an expression is bound to a value. In this case, the expression <code>sqrt (b ^ 2) - 4 * a * c</code> is bound to the name <code>d</code>. This name can now be used inside the <code>in</code> block, and indeed it is used twice. In this way, the <code>let .. in</code> construct helps to remove excess duplication.</p>
<p>Here’s a simpler example in the REPL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; let x = True in (True,x)</span><br><span class="line">(True,True)</span><br></pre></td></tr></table></figure>

<p>Here, we bound the value <code>True</code> to a local name <code>x</code> and used it inside the <code>in</code> block as a parameter to a tuple.</p>
<p>We can use more than one binding in the <code>let</code> block. Here’s yet another version of <code>roots</code>:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">roots&#x27;&#x27;</span> a b c =</span><br><span class="line">  <span class="keyword">let</span> d = sqrt (b ^ <span class="number">2</span> - <span class="number">4</span> * a * c)</span><br><span class="line">      x1 = (-b - d) / (<span class="number">2</span> * a)</span><br><span class="line">      x2 = (-b + d) / (<span class="number">2</span> * a)</span><br><span class="line">  <span class="keyword">in</span>  (x1, x2)</span><br></pre></td></tr></table></figure>

<p>Here we can see the use of indentation to group bindings inside the <code>let</code> block. Each binding can refer to the next, regardless of the order in which they were defined. Here’s one more change:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">roots&#x27;&#x27;&#x27;</span> a b c =</span><br><span class="line">  <span class="keyword">let</span></span><br><span class="line">    x1 = (-b - d) / aTwice</span><br><span class="line">    x2 = (-b + d) / aTwice</span><br><span class="line">    d  = sqrt (b ^ <span class="number">2</span> - <span class="number">4</span> * a * c)</span><br><span class="line">    aTwice = a * <span class="number">2</span></span><br><span class="line">  <span class="keyword">in</span> (x1, x2)</span><br></pre></td></tr></table></figure>

<p>The only requirement that indentation inside the <code>let</code> block is on the same level, otherwise this can cause syntax and compilation errors.</p>
<p>The <code>let .. in</code> construct can also be used to define local functions. In the previous section we defined a function <code>factorial5</code> with the helper function:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial5</span> = n | n &gt;= <span class="number">0</span>    = helper <span class="number">1</span> n</span><br><span class="line">               | otherwise = error <span class="string">&quot;arg must be &gt;= 0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title">helper</span> acc <span class="number">0</span> = acc</span><br><span class="line"><span class="title">helper</span> acc n = helper (acc * n) (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>Here, since the helper function was defined at indentation 0, it is now available to all other functions, even though only the factorial function requires it, polluting the global namespace. We can move it inside the <code>let</code> block, and rewrite it as follows:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial6</span> n</span><br><span class="line">  | n &gt;= <span class="number">0</span> = <span class="keyword">let</span></span><br><span class="line">      helper acc <span class="number">0</span> = acc</span><br><span class="line">      helper acc n = helper (acc * n) (n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">in</span> helper <span class="number">1</span> n</span><br><span class="line">  | otherwise error <span class="string">&quot;arg must be &gt;= 0&quot;</span></span><br></pre></td></tr></table></figure>

<p>Again, the only requirement here is keeping the indentation consistent.</p>
<p>We can also use <code>let .. in</code> to create a pattern. Suppose a function <code>rootsDiff</code>:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">rootsDiff</span> a b c = <span class="keyword">let</span></span><br><span class="line">  (x1,x2) = roots a b c</span><br><span class="line">  <span class="keyword">in</span> x2 - x1</span><br></pre></td></tr></table></figure>

<p>Here, instead of calling the <code>roots</code> function, later using the functions <code>fst</code> and <code>snd</code> to project the first and second values out of the pair, we use the <code>let</code> block to deconstruct the pair by using pattern matching, binding both pair values to the names <code>x1</code> and <code>x2</code>.</p>
<h4 id="Binding-using-where"><a href="#Binding-using-where" class="headerlink" title="Binding using where"></a>Binding using <code>where</code></h4><p>The <code>where</code> construct is similar to <code>let .. in</code>, except it works in the opposite - if <code>let .. in</code> allows us to declare bindings up front, and later use them, by using <code>where</code> we first specify the resulting expression, and only later specify the bindings.</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">roots&#x27;&#x27;&#x27;&#x27;</span> a b c = (x1, x2) <span class="keyword">where</span></span><br><span class="line">  x1 = (-b - d) / aTwice</span><br><span class="line">  x2 = (-b + d) / aTwice</span><br><span class="line">  d  = sqrt $ b ^ <span class="number">2</span> - <span class="number">4</span> * a * c</span><br><span class="line">  aTwice = a * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>Here we first declare the resulting pair <code>(x1, x2)</code>, followed by the <code>where</code> keyword, after which we declare all bindings.</p>
<p>The main difference between <code>let .. in</code> and <code>where</code>, other than the order, is the fact that <code>let .. in</code> is itself an expression that can be used in other expressions, while <code>where</code> is not an expression:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; let x = 2 in x ^ 2</span><br><span class="line">4</span><br><span class="line">&gt; (let x = 2 in x ^ 2) ^ 2</span><br><span class="line">16</span><br><span class="line">&gt; x ^ 2 where x = 2</span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:28:7: error: parse error on input ‘where’</span><br></pre></td></tr></table></figure>

<p>The <code>where</code> keyword can only be used inside a function definition and only in a specific place. This makes it suitable in cases where using the <code>let .. in</code> is not possible. Recall the last definition of <code>factorial6</code>:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial6</span> n</span><br><span class="line">  | n &gt;= <span class="number">0</span> = <span class="keyword">let</span></span><br><span class="line">      helper acc <span class="number">0</span> = acc</span><br><span class="line">      helper acc n = helper (acc * n) (n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">in</span> helper <span class="number">1</span> n</span><br><span class="line">  | otherwise error <span class="string">&quot;arg must be &gt;= 0&quot;</span></span><br></pre></td></tr></table></figure>

<p>Suppose we wanted to use the <code>helper</code> function not only in the first guard but also in other guard expressions. Because of the different guards, the entire body of <code>factorial6</code> is no longer a single expression. This is where the <code>where</code> style may become useful, allowing us to declare a common binding for all individual guard clauses:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial7</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">factorial7</span> n | n &gt;= <span class="number">0</span>    = helper <span class="number">1</span> n</span><br><span class="line">             | otherwise = error <span class="string">&quot;arg must be &gt;= 0&quot;</span></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    helper acc <span class="number">0</span> = acc</span><br><span class="line">    helper acc n = helper (acc * n) (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>Even though we’re not using the <code>helper</code> function in the <code>otherwise</code> case, it’s still available if we need it.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/right-fold-superpowers/" rel="prev" title="Right fold superpowers!">
      <i class="fa fa-chevron-left"></i> Right fold superpowers!
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/functional-programming-in-haskell-stepik-course-notes-module-2/" rel="next" title="Functional Programming in Haskell (Stepik course notes) - module 2">
      Functional Programming in Haskell (Stepik course notes) - module 2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Installing-and-configuring-GHC"><span class="nav-number">1.1.</span> <span class="nav-text">Installing and configuring GHC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-the-interpreter-GHCi"><span class="nav-number">1.1.1.</span> <span class="nav-text">Using the interpreter (GHCi)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Working-with-modules"><span class="nav-number">1.1.2.</span> <span class="nav-text">Working with modules</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Functions"><span class="nav-number">1.2.</span> <span class="nav-text">Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-application"><span class="nav-number">1.2.1.</span> <span class="nav-text">Function application</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Declaring-functions"><span class="nav-number">1.2.2.</span> <span class="nav-text">Declaring functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pure-functions"><span class="nav-number">1.2.3.</span> <span class="nav-text">Pure functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Conditions"><span class="nav-number">1.2.4.</span> <span class="nav-text">Conditions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Partial-application"><span class="nav-number">1.2.5.</span> <span class="nav-text">Partial application</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Operators"><span class="nav-number">1.3.</span> <span class="nav-text">Operators</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Operator-precedence-and-associativity"><span class="nav-number">1.3.1.</span> <span class="nav-text">Operator precedence and associativity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Operator-definition"><span class="nav-number">1.3.2.</span> <span class="nav-text">Operator definition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Operator-section"><span class="nav-number">1.3.3.</span> <span class="nav-text">Operator section</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-operator"><span class="nav-number">1.3.4.</span> <span class="nav-text">The $ operator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Base-types"><span class="nav-number">1.4.</span> <span class="nav-text">Base types</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Numeric-types"><span class="nav-number">1.4.1.</span> <span class="nav-text">Numeric types</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-types"><span class="nav-number">1.4.2.</span> <span class="nav-text">Function types</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Importing-functions"><span class="nav-number">1.4.3.</span> <span class="nav-text">Importing functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tuples"><span class="nav-number">1.4.4.</span> <span class="nav-text">Tuples</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lists"><span class="nav-number">1.4.5.</span> <span class="nav-text">Lists</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Recursion"><span class="nav-number">1.5.</span> <span class="nav-text">Recursion</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Pattern-matching"><span class="nav-number">1.5.1.</span> <span class="nav-text">Pattern matching</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Errors-and-early-termination"><span class="nav-number">1.5.2.</span> <span class="nav-text">Errors and early termination</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Guards"><span class="nav-number">1.5.3.</span> <span class="nav-text">Guards</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Recursion-with-accumulation"><span class="nav-number">1.5.4.</span> <span class="nav-text">Recursion with accumulation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Local-Bindings"><span class="nav-number">1.6.</span> <span class="nav-text">Local Bindings</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Significant-whitespace"><span class="nav-number">1.6.1.</span> <span class="nav-text">Significant whitespace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Removing-duplication-using-let-in"><span class="nav-number">1.6.2.</span> <span class="nav-text">Removing duplication using let .. in</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binding-using-where"><span class="nav-number">1.6.3.</span> <span class="nav-text">Binding using where</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Igal Tabachnik"
      src="https://avatars2.githubusercontent.com/u/601206?v=3&s=460">
  <p class="site-author-name" itemprop="name">Igal Tabachnik</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hmemcpy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hmemcpy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/hmemcpy" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;hmemcpy" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/8205/igal-tabachnik?tab=profile" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;8205&#x2F;igal-tabachnik?tab&#x3D;profile" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://il.linkedin.com/in/igaltabachnik" title="LinkedIn → https:&#x2F;&#x2F;il.linkedin.com&#x2F;in&#x2F;igaltabachnik" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2009 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Igal Tabachnik</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://hmemcpy.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://hmemcpy.com/2020/01/functional-programming-in-haskell-stepik-course-notes-module-1/";
    this.page.identifier = "2020/01/functional-programming-in-haskell-stepik-course-notes-module-1/";
    this.page.title = "Functional Programming in Haskell (Stepik course notes) - module 1";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://hmemcpy.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
